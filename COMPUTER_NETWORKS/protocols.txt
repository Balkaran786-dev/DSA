1. Stop-and-Wait Protocol
Sender:
perl
Copy
Edit
Initialize socket
Set sequence_number = 0


while data to send:
    packet = create_packet(data, sequence_number)
    send packet to receiver

    start timer
    wait for ACK or timeout

    if ACK received and ACK.seq == sequence_number:
        sequence_number = 1 - sequence_number   // toggle between 0 and 1
        move to next data chunk
    else if timeout:
        resend packet

Close socket


Receiver:
java
Copy
Edit
Initialize socket
expected_sequence_number = 0

while True:
    receive packet

    if packet.seq == expected_sequence_number:
        deliver data to upper layer
        send ACK with sequence_number = expected_sequence_number
        expected_sequence_number = 1 - expected_sequence_number
    else:
        resend ACK for last received correct packet

    
2. Go-Back-N Protocol
Sender:
csharp
Copy
Edit
Initialize socket
base = 0
next_seq_num = 0
window_size = N

buffer data to send

while data to send or unACKed packets exist:
    if next_seq_num < base + window_size and data remains:
        packet = create_packet(data[next_seq_num], next_seq_num)
        send packet
        if base == next_seq_num:
            start timer
        next_seq_num += 1

    wait for ACK or timeout

    if ACK received:
        base = ACK.number + 1
        if base == next_seq_num:
            stop timer
        else:
            restart timer
    else if timeout:
        resend all packets from base to next_seq_num - 1

Close socket

Receiver:
java
Copy
Edit
Initialize socket
expected_seq_num = 0

while True:
    receive packet

    if packet.seq == expected_seq_num:
        deliver data to upper layer
        send ACK with seq = expected_seq_num
        expected_seq_num += 1
    else:
        resend ACK for last correctly received packet (expected_seq_num - 1)
    
3. Selective Repeat Protocol
Sender:
csharp
Copy
Edit
Initialize socket
base = 0
next_seq_num = 0
window_size = N
buffer data to send
maintain timers for each sent packet

while data to send or unACKed packets exist:
    if next_seq_num < base + window_size and data remains:
        packet = create_packet(data[next_seq_num], next_seq_num)
        send packet
        start timer for this packet
        next_seq_num += 1

    wait for ACK or timeout

    if ACK received for seq_num:
        mark packet seq_num as acknowledged
        while base packet is acknowledged:
            base += 1
            stop timer for base - 1
    if timeout for any packet:
        resend that packet and restart timer

Close socket


Receiver:
sql
Copy
Edit
Initialize socket
expected_seq_num = base of receiver window
window_size = N
buffer = array to store out-of-order packets

while True:
    receive packet

    if packet.seq in receiver_window and not already received:
        buffer packet
        send ACK for packet.seq
        while buffer contains packet with seq == expected_seq_num:
            deliver data to upper layer
            remove from buffer
            expected_seq_num += 1
    else if packet.seq outside window or duplicate:
        resend ACK for that packet.seq
